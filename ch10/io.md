## IO

IO就是输入和输出，操作的是文件，文件的类型可以是普通文件，也可以是其他类型的文件，如设备文件，sock文件等。在计算机领域的一些基础理论课程上，往往重视调度而轻视IO。然而计算机的IO操作是最复杂的操作之一，而调度大部分情况是可以不必关心的，操作系统会处理好。通常的大部分操作其核心都是针对IO的操作。

### IO基本操作



### IO重定向

在shell中，重定向是经常要使用的功能。这里讨论的是IO重定向的原理并给出程序的实现。IO重定向的实现基于Linux的一个设计原则：

**最低可用文件描述符原则。**

简单来说，文件描述符是一个数组索引号，每个进程都记录了一组打开的文件，这组文件用一个数组来保存。数组的索引就是文件描述符。当一个进程在打开文件的时候，由于最低可用文件描述符原则，系统内核总会为此文件安排的描述符总是数组中最低可用的位置索引。

并且除此以外，还有一个依赖：文件描述符0，1，2作为标准输入，标准输出，标准错误输出和设备文件或者是其他类型的文件相关联。默认情况，0关联键盘对应的设备文件；1，2都是关联屏幕的设备文件。无论使用什么编程语言，当使用输出函数进行一些数据的输出时，就是输出到标准输出。当程序运行时，文件描述符0，1，2都是已经关联好的。

由于多数情况下就是在向关联的屏幕设备文件输出信息，所以这容易导致一个错误理解：输出函数就是直接向屏幕输出。而在Windows下，桌面环境根本就不考虑重定向的问题。

那程序如何控制重定向，以输出重定向为例。基于上文讨论的原则，当程序开始就使用close关闭描述符1。这个时候，最低可用文件描述符是1，此时open打开的文件，返回的描述符肯定是1。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int main(int argc, char *argv[])
{
    close(1);

    int fd = -1;
    
    fd = open("ioout",O_CREAT|O_APPEND|O_RDWR, S_IRUSR|S_IWUSR);
    if (fd<0) {
        perror("open");
        return -1;
    }

    printf("Linux is great\n");

    return 0;
}
```





### IO：阻塞和非阻塞

